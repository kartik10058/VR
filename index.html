<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pole Position VR</title>
    <!-- A-Frame 1.5.0 -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <!-- A-Frame Extras -->
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.2.0/dist/aframe-extras.min.js"></script>
    <!-- Tailwind -->
    <script src="https://cdn.tailwindcss.com"></script>

    <script>
      // --- UTILS ---
      // Generate a random float between min and max
      function randomRange(min, max) {
        return Math.random() * (max - min) + min;
      }

      // --- GAME STATE & MANAGER ---
      AFRAME.registerComponent('game-manager', {
        init: function() {
            this.ui = document.getElementById('game-ui');
            this.hud = document.getElementById('hud-overlay');
            this.startBtn = document.getElementById('start-btn');
            this.car = document.getElementById('f1-car');
            this.trackInfo = document.getElementById('track-generator');
            
            this.selectedColor = '#cc0000'; // Default Ferrari Red
            this.selectedTrack = 'oval';

            // Bind UI clicks
            document.querySelectorAll('.car-select').forEach(el => {
                el.addEventListener('click', (e) => {
                    // Visually select
                    document.querySelectorAll('.car-select').forEach(b => b.classList.remove('ring-4', 'ring-white'));
                    el.classList.add('ring-4', 'ring-white');
                    this.selectedColor = el.getAttribute('data-color');
                });
            });

            document.querySelectorAll('.track-select').forEach(el => {
                el.addEventListener('click', (e) => {
                    document.querySelectorAll('.track-select').forEach(b => b.classList.remove('bg-red-600'));
                    el.classList.add('bg-red-600');
                    this.selectedTrack = el.getAttribute('data-track');
                });
            });

            this.startBtn.addEventListener('click', () => this.startGame());
        },

        startGame: function() {
            // Unlock Audio
            const soundComp = this.car.components['car-sound'];
            if(soundComp) soundComp.unlockAudio();

            // Hide Menu, Show HUD
            this.ui.classList.add('hidden');
            this.hud.classList.remove('hidden');

            // Apply Car Color
            const carModel = document.getElementById('car-body-mesh');
            const carNose = document.getElementById('car-nose-mesh');
            if(carModel) carModel.setAttribute('color', this.selectedColor);
            if(carNose) carNose.setAttribute('color', this.selectedColor);

            // Generate Track
            const trackComp = this.trackInfo.components['track-system'];
            if(trackComp) {
                trackComp.generate(this.selectedTrack);
                
                // Teleport car to start
                const startPos = trackComp.getStartTransform();
                const physics = this.car.components['f1-physics'];
                
                // Set Position
                this.car.object3D.position.copy(startPos.position);
                // Set Rotation (ensure we face the right way)
                this.car.object3D.rotation.y = Math.atan2(
                    startPos.direction.x, 
                    startPos.direction.z
                ) + Math.PI; // Adjust for model orientation if needed
                
                // Reset Physics
                if(physics) physics.resetCar(true); // true = maintain position
            }
        }
      });

      // --- TRACK SYSTEM (Spline Based) ---
      AFRAME.registerComponent('track-system', {
        init: function() {
            this.curve = null;
            this.trackWidth = 14; 
        },

        generate: function(type) {
            // Clear old track
            while(this.el.firstChild) this.el.removeChild(this.el.firstChild);

            let points = [];
            
            if (type === 'oval') {
                // Simple Oval
                points = [
                    new THREE.Vector3(50, 0, 0),
                    new THREE.Vector3(20, 0, 80),
                    new THREE.Vector3(-20, 0, 80),
                    new THREE.Vector3(-50, 0, 0),
                    new THREE.Vector3(-20, 0, -80),
                    new THREE.Vector3(20, 0, -80),
                ];
            } else {
                // "The Serpent" - Complex
                points = [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, 100),
                    new THREE.Vector3(80, 0, 150),
                    new THREE.Vector3(120, 0, 100),
                    new THREE.Vector3(100, 0, 0),
                    new THREE.Vector3(150, 0, -100),
                    new THREE.Vector3(50, 0, -150),
                    new THREE.Vector3(-50, 0, -100),
                    new THREE.Vector3(-100, 0, 0),
                    new THREE.Vector3(-50, 0, 50),
                ];
            }

            // Close the loop
            this.curve = new THREE.CatmullRomCurve3(points);
            this.curve.closed = true;

            const samples = 400; 
            const tubeGeometry = new THREE.TubeGeometry(this.curve, samples, this.trackWidth / 2, 8, true);
            
            // WE NEED A FLAT TRACK, NOT A TUBE
            // Manual mesh generation for a flat road ribbon
            const spacedPoints = this.curve.getSpacedPoints(samples);
            this.frenetFrames = this.curve.computeFrenetFrames(samples, true);
            
            // Build visual elements
            this.buildVisuals(spacedPoints, this.frenetFrames);
            this.spawnCrowd(spacedPoints, this.frenetFrames);
        },

        buildVisuals: function(points, frames) {
            // Because creating custom BufferGeometry in A-Frame raw JS is verbose, 
            // we will approximate the track with many small planes/boxes for the floor
            // A better approach for "Production" is Custom Geometry, but let's use small segments for simplicity in DOM.
            
            // Actually, let's use a single mesh for performance (constructing THREE.Mesh)
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];
            const uvs = [];
            const indices = [];

            const width = this.trackWidth;
            
            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const nextP = points[(i + 1) % points.length];
                const tangent = frames.tangents[i];
                const normal = frames.normals[i];
                const binormal = frames.binormals[i];

                // Left and Right points
                // binormal is the vector pointing "sideways"
                const left = new THREE.Vector3().copy(p).add(binormal.clone().multiplyScalar(width/2));
                const right = new THREE.Vector3().copy(p).add(binormal.clone().multiplyScalar(-width/2));

                vertices.push(left.x, left.y + 0.05, left.z);
                vertices.push(right.x, right.y + 0.05, right.z);
                
                // Color (Asphalt dark grey)
                colors.push(0.2, 0.2, 0.2);
                colors.push(0.2, 0.2, 0.2);
            }

            // Create faces
            for (let i = 0; i < points.length; i++) {
                const currentLeft = i * 2;
                const currentRight = i * 2 + 1;
                const nextLeft = ((i + 1) % points.length) * 2;
                const nextRight = ((i + 1) % points.length) * 2 + 1;

                // Tri 1
                indices.push(currentLeft, nextLeft, currentRight);
                // Tri 2
                indices.push(nextLeft, nextRight, currentRight);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();

            const material = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, 
                vertexColors: true,
                roughness: 0.8 
            });
            const mesh = new THREE.Mesh(geometry, material);
            this.el.setObject3D('mesh', mesh);

            // Add Kerbs (Separate entities for simplicity/visual pop)
            for (let i = 0; i < points.length; i+=5) { // every 5th segment
                if (i >= points.length) break;
                
                const p = points[i];
                const binormal = frames.binormals[i];
                
                // Left Kerb
                const kerbL = document.createElement('a-box');
                const kPosL = new THREE.Vector3().copy(p).add(binormal.clone().multiplyScalar((width/2) + 0.5));
                kerbL.setAttribute('position', kPosL);
                kerbL.setAttribute('width', 1);
                kerbL.setAttribute('height', 0.2);
                kerbL.setAttribute('depth', 2);
                kerbL.setAttribute('color', (i/5)%2===0 ? 'red' : 'white');
                kerbL.setAttribute('look-at', `0 0 0`); // Placeholder, updated below
                
                // Right Kerb
                const kerbR = document.createElement('a-box');
                const kPosR = new THREE.Vector3().copy(p).add(binormal.clone().multiplyScalar(-(width/2) - 0.5));
                kerbR.setAttribute('position', kPosR);
                kerbR.setAttribute('width', 1);
                kerbR.setAttribute('height', 0.2);
                kerbR.setAttribute('depth', 2);
                kerbR.setAttribute('color', (i/5)%2===0 ? 'white' : 'red');

                // Align rotation roughly to track
                // A bit hacky without calculating exact Euler from frames
                const tangent = frames.tangents[i];
                const angle = Math.atan2(tangent.x, tangent.z);
                const deg = angle * (180/Math.PI);
                
                kerbL.setAttribute('rotation', `0 ${deg} 0`);
                kerbR.setAttribute('rotation', `0 ${deg} 0`);

                this.el.appendChild(kerbL);
                this.el.appendChild(kerbR);
            }
        },

        spawnCrowd: function(points, frames) {
            // Place crowd clusters
            for(let i=0; i<points.length; i+=15) {
                const p = points[i];
                const binormal = frames.binormals[i];
                
                // Pick a side (Left or Right)
                const side = Math.random() > 0.5 ? 1 : -1;
                const dist = (this.trackWidth/2) + 4 + Math.random() * 2;
                
                const pos = new THREE.Vector3().copy(p).add(binormal.clone().multiplyScalar(side * dist));

                // Create a "Grandstand" block
                const stand = document.createElement('a-entity');
                stand.setAttribute('position', pos);
                const tangent = frames.tangents[i];
                const angle = Math.atan2(tangent.x, tangent.z);
                stand.setAttribute('rotation', `0 ${angle * (180/Math.PI) + (side===1?-90:90)} 0`);

                // Crowd Members
                for(let j=0; j<5; j++) {
                    const human = document.createElement('a-cylinder');
                    human.setAttribute('position', `${(j-2)*0.6} 1 ${0}`);
                    human.setAttribute('radius', 0.25);
                    human.setAttribute('height', 0.8 + Math.random()*0.2);
                    // Random bright colors
                    const color = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff'][Math.floor(Math.random()*5)];
                    human.setAttribute('color', color);
                    
                    // Add animation (Cheering/Jumping)
                    human.setAttribute('animation', `property: position; to: ${(j-2)*0.6} 1.5 0; dir: alternate; dur: ${400 + Math.random()*200}; loop: true; easing: easeInOutQuad`);
                    
                    stand.appendChild(human);
                }
                
                this.el.appendChild(stand);
            }
        },

        getStartTransform: function() {
            if (!this.curve) return { position: new THREE.Vector3(0,0,0), direction: new THREE.Vector3(0,0,1) };
            const p = this.curve.getPointAt(0);
            const t = this.curve.getTangentAt(0);
            return { position: new THREE.Vector3(p.x, p.y + 0.2, p.z), direction: t };
        },

        // Returns distance from center line. 0 = center.
        getDistanceFromCenter: function(position) {
            if (!this.curve) return 0;
            // Finding the closest point on a curve is expensive to do perfectly every frame.
            // We approximate by checking divisions.
            // Optimized: In a real engine we'd use spatial partition. Here we just scan 100 points.
            // Or better: Assume the car moves along the track index.
            
            // Simplified fallback: Just check distance to 0,0 for oval? No, curve is complex.
            // Let's iterate coarse samples.
            let minD = Infinity;
            // Optimization: We could track "current segment index" in physics to only check neighbors.
            
            // Fast scan
            const divisions = 50; 
            for(let i=0; i<=divisions; i++) {
                const t = i/divisions;
                const p = this.curve.getPointAt(t);
                const d = p.distanceToSquared(position);
                if(d < minD) minD = d;
            }
            return Math.sqrt(minD);
        }
      });

      // --- CAR SOUND COMPONENT ---
      AFRAME.registerComponent('car-sound', {
          init: function() {
             this.audioCtx = null;
             this.engineOsc = null;
             this.engineGain = null;
          },
          unlockAudio: function() {
              const AudioContext = window.AudioContext || window.webkitAudioContext;
              if (AudioContext) {
                 this.audioCtx = new AudioContext();
                 
                 // Engine Synth
                 this.engineOsc = this.audioCtx.createOscillator();
                 this.engineGain = this.audioCtx.createGain();
                 this.engineOsc.type = 'sawtooth';
                 this.engineOsc.frequency.value = 100;
                 this.engineOsc.connect(this.engineGain);
                 this.engineGain.connect(this.audioCtx.destination);
                 this.engineGain.gain.value = 0.0;
                 this.engineOsc.start();
              }
          },
          updateSound: function(rpm, load) {
              if(!this.audioCtx || !this.engineOsc) return;
              
              const baseFreq = 70;
              // RPM maps 0..12000 -> Freq 70..600
              const freq = baseFreq + (rpm * 0.04);
              this.engineOsc.frequency.setTargetAtTime(freq, this.audioCtx.currentTime, 0.1);
              
              // Volume shake
              const vol = 0.1 + (load * 0.1);
              this.engineGain.gain.setTargetAtTime(vol, this.audioCtx.currentTime, 0.1);
          }
      });

      // --- F1 PHYSICS COMPONENT (UPDATED) ---
      AFRAME.registerComponent('f1-physics', {
        schema: {
          acceleration: { type: 'number', default: 45 },
          braking: { type: 'number', default: 90 },
          maxSpeed: { type: 'number', default: 90 },
          friction: { type: 'number', default: 0.5 },
          drag: { type: 'number', default: 0.02 },
          turnSpeed: { type: 'number', default: 2.2 }
        },

        init: function () {
          this.velocity = new THREE.Vector3(0, 0, 0);
          this.speed = 0;
          this.rpm = 0;
          this.viewMode = 'cockpit';
          
          this.inputs = { forward: false, backward: false, left: false, right: false, steerValue: 0, gasValue: 0, brakeValue: 0 };

          this.cockpitCam = document.querySelector('#cam-cockpit');
          this.chaseCam = document.querySelector('#cam-chase');
          this.frontWheels = document.querySelectorAll('.wheel-front');
          this.speedLines = document.querySelector('#speed-lines');
          this.hudSpeed = document.querySelector('#hud-speed');
          this.hudRpmBar = document.querySelector('#hud-rpm-bar');
          this.trackSystem = document.querySelector('[track-system]').components['track-system'];
          
          this.bindKeys();
        },

        bindKeys: function () {
          window.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
              case 'w': this.inputs.forward = true; break;
              case 's': this.inputs.backward = true; break;
              case 'a': this.inputs.left = true; break;
              case 'd': this.inputs.right = true; break;
              case 'v': this.toggleCamera(); break;
              case 'r': this.resetCar(); break;
            }
          });
          window.addEventListener('keyup', (e) => {
            switch(e.key.toLowerCase()) {
              case 'w': this.inputs.forward = false; break;
              case 's': this.inputs.backward = false; break;
              case 'a': this.inputs.left = false; break;
              case 'd': this.inputs.right = false; break;
            }
          });
          this.el.sceneEl.addEventListener('abuttondown', () => this.toggleCamera());
          this.el.sceneEl.addEventListener('bbuttondown', () => this.resetCar());
        },

        toggleCamera: function () {
          this.viewMode = this.viewMode === 'cockpit' ? 'chase' : 'cockpit';
          if (this.viewMode === 'cockpit') {
            this.cockpitCam.setAttribute('active', true);
            this.chaseCam.setAttribute('active', false);
          } else {
            this.cockpitCam.setAttribute('active', false);
            this.chaseCam.setAttribute('active', true);
          }
        },

        resetCar: function (keepPosition = false) {
            if(!keepPosition) {
                // If fell off world
                const start = this.trackSystem.getStartTransform();
                this.el.object3D.position.copy(start.position);
                this.el.object3D.rotation.y = Math.atan2(start.direction.x, start.direction.z) + Math.PI;
            }
            this.velocity.set(0,0,0);
            this.speed = 0;
        },

        tick: function (time, timeDelta) {
          const dt = timeDelta / 1000;
          if (dt > 0.1) return;

          this.pollControllers();

          // Input processing
          let throttle = this.inputs.forward ? 1 : this.inputs.gasValue;
          let brake = this.inputs.backward ? 1 : this.inputs.brakeValue;

          // Physics Vectors
          const forwardDir = new THREE.Vector3(0, 0, -1).applyQuaternion(this.el.object3D.quaternion);
          
          // --- OFF-TRACK LOGIC ---
          // Check track limits
          const distanceFromCenter = this.trackSystem.getDistanceFromCenter(this.el.object3D.position);
          const limit = (this.trackSystem.trackWidth / 2) - 1.0; 
          const isOffTrack = distanceFromCenter > limit;
          
          // Surface Friction
          let currentFriction = this.data.friction;
          let currentDrag = this.data.drag;
          
          if (isOffTrack) {
             // Gravel Trap Effect
             currentFriction = 5.0; // Huge rolling resistance
             currentDrag = 0.5;
             throttle *= 0.2; // Power cut
             // Visual shake could be added here
          }

          // Acceleration
          if (throttle > 0 && this.speed < this.data.maxSpeed) {
            const acc = forwardDir.clone().multiplyScalar(this.data.acceleration * throttle * dt);
            this.velocity.add(acc);
          }

          // Braking
          if (brake > 0) {
            const brakeForce = this.velocity.clone().normalize().multiplyScalar(-this.data.braking * brake * dt);
            this.velocity.add(brakeForce);
          }

          // Drag/Friction
          this.velocity.multiplyScalar(1 - (currentDrag * dt));
          if (throttle === 0 || isOffTrack) {
             this.velocity.multiplyScalar(1 - (currentFriction * dt));
          }

          // Speed calculation
          this.speed = this.velocity.length();
          
          // Steering
          let steerInput = 0;
          if (this.inputs.left) steerInput = 1;
          if (this.inputs.right) steerInput = -1;
          if (Math.abs(this.inputs.steerValue) > 0.1) steerInput = -this.inputs.steerValue;

          // Variable Steering Ratio
          const speedFactor = Math.max(0.3, 1 - (this.speed / this.data.maxSpeed) * 0.7);
          // If offroad, steering is sluggish
          const surfaceSteer = isOffTrack ? 0.5 : 1.0;
          
          const rotationAmount = steerInput * this.data.turnSpeed * speedFactor * surfaceSteer * dt * (this.speed > 1 ? 1 : 0);
          this.el.object3D.rotation.y += rotationAmount;

          // Apply Movement
          this.el.object3D.position.add(this.velocity.clone().multiplyScalar(dt));

          // Wheel Visuals
          const wheelRot = (this.speed * dt * 50);
          this.frontWheels.forEach(wheel => {
            wheel.object3D.rotation.x -= wheelRot;
            wheel.object3D.rotation.y = steerInput * 0.5;
          });

          // Speed Lines
          if (this.speedLines) {
             const opacity = Math.min((this.speed / this.data.maxSpeed), 0.8);
             this.speedLines.setAttribute('visible', this.speed > 10);
             this.speedLines.setAttribute('opacity', opacity);
          }

          // HUD
          const kph = Math.floor(this.speed * 3.6);
          this.rpm = (this.speed / this.data.maxSpeed) * 12000 + (throttle * 1000);
          
          if (this.hudSpeed) this.hudSpeed.setAttribute('value', `${kph}`);
          if (this.hudRpmBar) {
             const scaleX = Math.min(this.rpm / 13000, 1);
             this.hudRpmBar.object3D.scale.set(scaleX, 1, 1);
             const r = scaleX > 0.8 ? 1 : 0;
             const g = scaleX < 0.9 ? 1 : 0;
             this.hudRpmBar.setAttribute('color', isOffTrack ? '#ffaa00' : `rgb(${r*255}, ${g*255}, 0)`);
          }

          // Sound
          const soundComp = this.el.components['car-sound'];
          if(soundComp) soundComp.updateSound(this.rpm, throttle);

          // Boundaries Reset (Fall off map)
          if (this.el.object3D.position.y < -10) this.resetCar();
        },

        pollControllers: function() {
           const gamepads = navigator.getGamepads();
           if (!gamepads) return;
           for (let i = 0; i < gamepads.length; i++) {
               const gp = gamepads[i];
               if (gp) {
                   if (gp.axes.length >= 2) this.inputs.steerValue = gp.axes[2] || gp.axes[0]; 
                   if (gp.buttons.length > 0) {
                      if (gp.id.includes('right') || gp.id.includes('Right')) this.inputs.gasValue = gp.buttons[0].value;
                      if (gp.id.includes('left') || gp.id.includes('Left')) this.inputs.brakeValue = gp.buttons[0].value;
                   }
               }
           }
        }
      });
    </script>
  </head>
  <body>
    <!-- MAIN UI MENU -->
    <div id="game-ui" class="absolute inset-0 z-50 flex flex-col items-center justify-center bg-zinc-900 text-white font-sans transition-all duration-500">
        <!-- Background Decor -->
        <div class="absolute inset-0 bg-[url('https://images.unsplash.com/photo-1541447271487-09612b3f49f7?q=80&w=1000')] bg-cover opacity-30"></div>
        <div class="absolute inset-0 bg-gradient-to-t from-black via-transparent to-black"></div>

        <div class="relative z-10 text-center space-y-8 p-8 max-w-4xl w-full">
            <h1 class="text-6xl md:text-8xl font-black italic tracking-tighter drop-shadow-[0_4px_4px_rgba(255,0,0,0.8)]">
                POLE <span class="text-red-600">POSITION</span> VR
            </h1>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8 bg-black/60 p-6 rounded-xl backdrop-blur-md border border-zinc-700">
                <!-- Car Selection -->
                <div class="space-y-4">
                    <h2 class="text-2xl font-bold border-b border-zinc-500 pb-2">SELECT TEAM</h2>
                    <div class="grid grid-cols-3 gap-4">
                        <button data-color="#cc0000" class="car-select ring-4 ring-white bg-red-700 h-20 rounded-lg hover:scale-105 transition shadow-lg shadow-red-900/50 flex items-center justify-center font-bold">SCUDERIA</button>
                        <button data-color="#c0c0c0" class="car-select bg-gray-400 h-20 rounded-lg hover:scale-105 transition shadow-lg shadow-gray-500/50 flex items-center justify-center font-bold text-black">SILVER</button>
                        <button data-color="#ff8700" class="car-select bg-orange-500 h-20 rounded-lg hover:scale-105 transition shadow-lg shadow-orange-600/50 flex items-center justify-center font-bold text-black">PAPAYA</button>
                    </div>
                </div>

                <!-- Track Selection -->
                <div class="space-y-4">
                    <h2 class="text-2xl font-bold border-b border-zinc-500 pb-2">SELECT CIRCUIT</h2>
                    <div class="space-y-2">
                        <button data-track="oval" class="track-select w-full bg-red-600 p-3 rounded font-bold text-left hover:bg-red-500 transition flex justify-between items-center group">
                            <span>SUPER OVAL <span class="text-xs font-normal opacity-70 ml-2">High Speed</span></span>
                            <span class="group-hover:translate-x-2 transition">→</span>
                        </button>
                        <button data-track="serpent" class="track-select w-full bg-zinc-800 p-3 rounded font-bold text-left hover:bg-zinc-700 transition flex justify-between items-center group">
                            <span>THE SERPENT <span class="text-xs font-normal opacity-70 ml-2">Technical</span></span>
                            <span class="group-hover:translate-x-2 transition">→</span>
                        </button>
                    </div>
                </div>
            </div>

            <button id="start-btn" class="px-12 py-4 bg-white text-black font-black text-2xl rounded hover:bg-yellow-400 hover:scale-110 transition shadow-[0_0_20px_rgba(255,255,255,0.5)] uppercase italic">
                Start Engine
            </button>

            <p class="text-sm text-zinc-400 font-mono">
                CONTROLS: WASD to Drive • V to Change Cam • VR Controllers Supported
            </p>
        </div>
    </div>

    <!-- IN-GAME HUD (Initially Hidden) -->
    <div id="hud-overlay" class="absolute top-4 left-4 z-40 pointer-events-none hidden">
         <div class="mt-2 text-white/80 text-sm font-mono bg-black/50 p-4 rounded backdrop-blur-md border-l-4 border-red-600">
          <p class="font-bold mb-2">CONTROLS</p>
          <div class="grid grid-cols-2 gap-x-8 gap-y-1">
            <span>Throttle</span> <span class="text-yellow-400">W / Trigger</span>
            <span>Brake</span> <span class="text-yellow-400">S / Left Trig</span>
            <span>View</span> <span class="text-yellow-400">V / A Btn</span>
            <span>Reset</span> <span class="text-yellow-400">R / B Btn</span>
          </div>
        </div>
    </div>

    <!-- SCENE -->
    <a-scene 
        game-manager
        physics="debug: false" 
        background="color: #87CEEB" 
        renderer="antialias: true; colorManagement: true; foveationLevel: 3; highRefreshRate: true; exposure: 1.2; toneMapping: ACESFilmic;"
    >
        <a-assets>
            <img id="sky-tex" src="https://cdn.jsdelivr.net/npm/three-examples@latest/examples/textures/cube/Park2/posy.jpg" crossorigin="anonymous">
        </a-assets>

        <!-- Lighting & Env -->
        <a-sky color="#87CEEB"></a-sky> <!-- Simple sky, or can use gradient shader -->
        
        <a-light type="directional" position="-5 10 5" castShadow="true" intensity="1.5" shadow-bias="-0.0001" shadow-camera-size="50"></a-light>
        <a-light type="hemisphere" color="#fff" groundColor="#444" intensity="0.6"></a-light>
        <a-fog type="exponential" color="#87CEEB" density="0.002"></a-fog>
        
        <!-- Infinite Grass Floor -->
        <a-plane position="0 -0.1 0" rotation="-90 0 0" width="2000" height="2000" color="#3a5f0b" roughness="1" metalness="0"></a-plane>

        <!-- Dynamic Track System -->
        <a-entity id="track-generator" track-system></a-entity>
        
        <!-- F1 Car Rig -->
        <a-entity id="f1-car" car-sound f1-physics position="0 0.2 0" rotation="0 0 0">
            
            <!-- CAMERAS -->
            <a-entity id="camera-rig">
                <a-camera id="cam-cockpit" position="0 0.85 -0.2" active="true" look-controls="enabled: true" wasd-controls-enabled="false">
                    <a-entity position="0 -0.4 -0.5" rotation="-15 0 0">
                            <!-- HUD -->
                            <a-plane width="0.4" height="0.2" color="#111" opacity="0.8" material="shader: flat; transparent: true"></a-plane>
                            <a-text id="hud-speed" value="0" position="0 0.02 0.01" align="center" width="2" color="#fff" font="mozillavr"></a-text>
                            <a-text value="KPH" position="0 -0.05 0.01" align="center" width="0.8" color="#aaa"></a-text>
                            <a-box position="0 0.08 0.01" width="0.35" height="0.02" depth="0.001" color="#333"></a-box>
                            <a-box id="hud-rpm-bar" position="-0.175 0.08 0.015" pivot="0.175 0 0" width="0.35" height="0.015" depth="0.001" color="#0f0"></a-box>
                    </a-entity>
                </a-camera>

                <a-camera id="cam-chase" position="0 2.5 4.5" active="false" look-controls="enabled: false" wasd-controls-enabled="false" rotation="-15 0 0"></a-camera>
            </a-entity>

            <!-- CAR MODEL -->
            <a-entity id="car-model" shadow="receive: true; cast: true">
                <!-- Body colored parts -->
                <a-box id="car-body-mesh" position="0 0.3 0" width="0.5" height="0.3" depth="3.5" color="#cc0000" material="roughness: 0.3; metalness: 0.4"></a-box>
                <a-cone id="car-nose-mesh" position="0 0.25 -2.25" radius-bottom="0.25" radius-top="0.05" height="1" rotation="90 0 0" color="#cc0000" material="roughness: 0.3; metalness: 0.4"></a-cone>
                
                <!-- Dark Carbon Parts -->
                <a-box position="0 0.45 -0.3" width="0.4" height="0.2" depth="1.2" color="#111"></a-box>
                
                <!-- Halo -->
                <a-torus position="0 0.65 -0.3" radius="0.3" radius-tubular="0.02" arc="180" rotation="0 0 90" color="#111"></a-torus>
                <a-cylinder position="0 0.65 -0.8" radius="0.02" height="0.4" rotation="45 0 0" color="#111"></a-cylinder>

                <!-- Wings -->
                <a-box position="0 0.1 -2.7" width="1.8" height="0.05" depth="0.4" color="#111"></a-box>
                <a-box position="0 0.8 1.6" width="1.6" height="0.05" depth="0.4" color="#111"></a-box>
                <a-box position="0.7 0.5 1.6" width="0.05" height="0.6" depth="0.4" color="#111"></a-box>
                <a-box position="-0.7 0.5 1.6" width="0.05" height="0.6" depth="0.4" color="#111"></a-box>

                <!-- Wheels -->
                <a-cylinder class="wheel-front" position="-0.85 0.35 -1.8" rotation="0 0 90" radius="0.35" height="0.35" color="#111" material="roughness: 0.9">
                        <a-ring radius-inner="0.15" radius-outer="0.35" position="0 0.18 0" color="#333"></a-ring>
                </a-cylinder>
                <a-cylinder class="wheel-front" position="0.85 0.35 -1.8" rotation="0 0 90" radius="0.35" height="0.35" color="#111" material="roughness: 0.9">
                        <a-ring radius-inner="0.15" radius-outer="0.35" position="0 -0.18 0" color="#333"></a-ring>
                </a-cylinder>
                <a-cylinder class="wheel-rear" position="-0.9 0.35 1.2" rotation="0 0 90" radius="0.35" height="0.45" color="#111" material="roughness: 0.9">
                        <a-ring radius-inner="0.15" radius-outer="0.35" position="0 0.23 0" color="#333"></a-ring>
                </a-cylinder>
                <a-cylinder class="wheel-rear" position="0.9 0.35 1.2" rotation="0 0 90" radius="0.35" height="0.45" color="#111" material="roughness: 0.9">
                        <a-ring radius-inner="0.15" radius-outer="0.35" position="0 -0.23 0" color="#333"></a-ring>
                </a-cylinder>

                <!-- Steering Wheel -->
                <a-entity position="0 0.45 -0.6" rotation="-20 0 0">
                    <a-box width="0.3" height="0.15" depth="0.05" color="#222"></a-box>
                    <a-cylinder rotation="90 0 0" radius="0.15" height="0.05" segments-radial="8" theta-length="180" rotation-z="90" position="-0.15 0 0" color="#222"></a-cylinder>
                    <a-cylinder rotation="90 0 0" radius="0.15" height="0.05" segments-radial="8" theta-length="180" theta-start="180" position="0.15 0 0" color="#222"></a-cylinder>
                </a-entity>

                <!-- Speed Lines -->
                <a-cylinder id="speed-lines" position="0 0 0" rotation="90 0 0" radius="3" height="10" open-ended="true" side="back" visible="false" opacity="0"
                    material="shader: flat; color: #fff; transparent: true; src: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAYAAABytg0kAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABZJREFUeNpiYGBgAAJ0EA0CJgYQYAACAAwAAwlH39gAAAAASUVORK5CYII=); repeat: 10 1">
                </a-cylinder>

            </a-entity>
        </a-entity>

        <!-- Controllers -->
        <a-entity id="left-hand" oculus-touch-controls="hand: left"></a-entity>
        <a-entity id="right-hand" oculus-touch-controls="hand: right"></a-entity>

    </a-scene>
  </body>
</html>
